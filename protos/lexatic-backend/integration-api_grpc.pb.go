// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.3.0
// - protoc             v3.20.3
// source: lexatic-backend/integration-api.proto

package lexatic_backend

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

const (
	OpenAiService_Chat_FullMethodName     = "/integration_api.OpenAiService/Chat"
	OpenAiService_Generate_FullMethodName = "/integration_api.OpenAiService/Generate"
)

// OpenAiServiceClient is the client API for OpenAiService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type OpenAiServiceClient interface {
	Chat(ctx context.Context, in *OpenAiChatRequest, opts ...grpc.CallOption) (*OpenAiChatResponse, error)
	Generate(ctx context.Context, in *OpenAiGenerateRequest, opts ...grpc.CallOption) (*OpenAiGenerateResponse, error)
}

type openAiServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewOpenAiServiceClient(cc grpc.ClientConnInterface) OpenAiServiceClient {
	return &openAiServiceClient{cc}
}

func (c *openAiServiceClient) Chat(ctx context.Context, in *OpenAiChatRequest, opts ...grpc.CallOption) (*OpenAiChatResponse, error) {
	out := new(OpenAiChatResponse)
	err := c.cc.Invoke(ctx, OpenAiService_Chat_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *openAiServiceClient) Generate(ctx context.Context, in *OpenAiGenerateRequest, opts ...grpc.CallOption) (*OpenAiGenerateResponse, error) {
	out := new(OpenAiGenerateResponse)
	err := c.cc.Invoke(ctx, OpenAiService_Generate_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// OpenAiServiceServer is the server API for OpenAiService service.
// All implementations should embed UnimplementedOpenAiServiceServer
// for forward compatibility
type OpenAiServiceServer interface {
	Chat(context.Context, *OpenAiChatRequest) (*OpenAiChatResponse, error)
	Generate(context.Context, *OpenAiGenerateRequest) (*OpenAiGenerateResponse, error)
}

// UnimplementedOpenAiServiceServer should be embedded to have forward compatible implementations.
type UnimplementedOpenAiServiceServer struct {
}

func (UnimplementedOpenAiServiceServer) Chat(context.Context, *OpenAiChatRequest) (*OpenAiChatResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Chat not implemented")
}
func (UnimplementedOpenAiServiceServer) Generate(context.Context, *OpenAiGenerateRequest) (*OpenAiGenerateResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Generate not implemented")
}

// UnsafeOpenAiServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to OpenAiServiceServer will
// result in compilation errors.
type UnsafeOpenAiServiceServer interface {
	mustEmbedUnimplementedOpenAiServiceServer()
}

func RegisterOpenAiServiceServer(s grpc.ServiceRegistrar, srv OpenAiServiceServer) {
	s.RegisterService(&OpenAiService_ServiceDesc, srv)
}

func _OpenAiService_Chat_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(OpenAiChatRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OpenAiServiceServer).Chat(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: OpenAiService_Chat_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OpenAiServiceServer).Chat(ctx, req.(*OpenAiChatRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _OpenAiService_Generate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(OpenAiGenerateRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OpenAiServiceServer).Generate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: OpenAiService_Generate_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OpenAiServiceServer).Generate(ctx, req.(*OpenAiGenerateRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// OpenAiService_ServiceDesc is the grpc.ServiceDesc for OpenAiService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var OpenAiService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "integration_api.OpenAiService",
	HandlerType: (*OpenAiServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Chat",
			Handler:    _OpenAiService_Chat_Handler,
		},
		{
			MethodName: "Generate",
			Handler:    _OpenAiService_Generate_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "lexatic-backend/integration-api.proto",
}

const (
	CohereService_Chat_FullMethodName     = "/integration_api.CohereService/Chat"
	CohereService_Generate_FullMethodName = "/integration_api.CohereService/Generate"
)

// CohereServiceClient is the client API for CohereService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type CohereServiceClient interface {
	Chat(ctx context.Context, in *CohereChatRequest, opts ...grpc.CallOption) (*CohereChatResponse, error)
	Generate(ctx context.Context, in *CohereGenerateRequest, opts ...grpc.CallOption) (*CohereGenerateResponse, error)
}

type cohereServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewCohereServiceClient(cc grpc.ClientConnInterface) CohereServiceClient {
	return &cohereServiceClient{cc}
}

func (c *cohereServiceClient) Chat(ctx context.Context, in *CohereChatRequest, opts ...grpc.CallOption) (*CohereChatResponse, error) {
	out := new(CohereChatResponse)
	err := c.cc.Invoke(ctx, CohereService_Chat_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cohereServiceClient) Generate(ctx context.Context, in *CohereGenerateRequest, opts ...grpc.CallOption) (*CohereGenerateResponse, error) {
	out := new(CohereGenerateResponse)
	err := c.cc.Invoke(ctx, CohereService_Generate_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// CohereServiceServer is the server API for CohereService service.
// All implementations should embed UnimplementedCohereServiceServer
// for forward compatibility
type CohereServiceServer interface {
	Chat(context.Context, *CohereChatRequest) (*CohereChatResponse, error)
	Generate(context.Context, *CohereGenerateRequest) (*CohereGenerateResponse, error)
}

// UnimplementedCohereServiceServer should be embedded to have forward compatible implementations.
type UnimplementedCohereServiceServer struct {
}

func (UnimplementedCohereServiceServer) Chat(context.Context, *CohereChatRequest) (*CohereChatResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Chat not implemented")
}
func (UnimplementedCohereServiceServer) Generate(context.Context, *CohereGenerateRequest) (*CohereGenerateResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Generate not implemented")
}

// UnsafeCohereServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to CohereServiceServer will
// result in compilation errors.
type UnsafeCohereServiceServer interface {
	mustEmbedUnimplementedCohereServiceServer()
}

func RegisterCohereServiceServer(s grpc.ServiceRegistrar, srv CohereServiceServer) {
	s.RegisterService(&CohereService_ServiceDesc, srv)
}

func _CohereService_Chat_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CohereChatRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CohereServiceServer).Chat(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CohereService_Chat_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CohereServiceServer).Chat(ctx, req.(*CohereChatRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CohereService_Generate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CohereGenerateRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CohereServiceServer).Generate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CohereService_Generate_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CohereServiceServer).Generate(ctx, req.(*CohereGenerateRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// CohereService_ServiceDesc is the grpc.ServiceDesc for CohereService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var CohereService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "integration_api.CohereService",
	HandlerType: (*CohereServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Chat",
			Handler:    _CohereService_Chat_Handler,
		},
		{
			MethodName: "Generate",
			Handler:    _CohereService_Generate_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "lexatic-backend/integration-api.proto",
}

const (
	AnthropicService_Chat_FullMethodName     = "/integration_api.AnthropicService/Chat"
	AnthropicService_Generate_FullMethodName = "/integration_api.AnthropicService/Generate"
)

// AnthropicServiceClient is the client API for AnthropicService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type AnthropicServiceClient interface {
	Chat(ctx context.Context, in *AnthropicChatRequest, opts ...grpc.CallOption) (*AnthropicChatResponse, error)
	Generate(ctx context.Context, in *AnthropicGenerateRequest, opts ...grpc.CallOption) (*AnthropicGenerateResponse, error)
}

type anthropicServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewAnthropicServiceClient(cc grpc.ClientConnInterface) AnthropicServiceClient {
	return &anthropicServiceClient{cc}
}

func (c *anthropicServiceClient) Chat(ctx context.Context, in *AnthropicChatRequest, opts ...grpc.CallOption) (*AnthropicChatResponse, error) {
	out := new(AnthropicChatResponse)
	err := c.cc.Invoke(ctx, AnthropicService_Chat_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *anthropicServiceClient) Generate(ctx context.Context, in *AnthropicGenerateRequest, opts ...grpc.CallOption) (*AnthropicGenerateResponse, error) {
	out := new(AnthropicGenerateResponse)
	err := c.cc.Invoke(ctx, AnthropicService_Generate_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// AnthropicServiceServer is the server API for AnthropicService service.
// All implementations should embed UnimplementedAnthropicServiceServer
// for forward compatibility
type AnthropicServiceServer interface {
	Chat(context.Context, *AnthropicChatRequest) (*AnthropicChatResponse, error)
	Generate(context.Context, *AnthropicGenerateRequest) (*AnthropicGenerateResponse, error)
}

// UnimplementedAnthropicServiceServer should be embedded to have forward compatible implementations.
type UnimplementedAnthropicServiceServer struct {
}

func (UnimplementedAnthropicServiceServer) Chat(context.Context, *AnthropicChatRequest) (*AnthropicChatResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Chat not implemented")
}
func (UnimplementedAnthropicServiceServer) Generate(context.Context, *AnthropicGenerateRequest) (*AnthropicGenerateResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Generate not implemented")
}

// UnsafeAnthropicServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to AnthropicServiceServer will
// result in compilation errors.
type UnsafeAnthropicServiceServer interface {
	mustEmbedUnimplementedAnthropicServiceServer()
}

func RegisterAnthropicServiceServer(s grpc.ServiceRegistrar, srv AnthropicServiceServer) {
	s.RegisterService(&AnthropicService_ServiceDesc, srv)
}

func _AnthropicService_Chat_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AnthropicChatRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AnthropicServiceServer).Chat(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AnthropicService_Chat_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AnthropicServiceServer).Chat(ctx, req.(*AnthropicChatRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AnthropicService_Generate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AnthropicGenerateRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AnthropicServiceServer).Generate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AnthropicService_Generate_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AnthropicServiceServer).Generate(ctx, req.(*AnthropicGenerateRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// AnthropicService_ServiceDesc is the grpc.ServiceDesc for AnthropicService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var AnthropicService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "integration_api.AnthropicService",
	HandlerType: (*AnthropicServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Chat",
			Handler:    _AnthropicService_Chat_Handler,
		},
		{
			MethodName: "Generate",
			Handler:    _AnthropicService_Generate_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "lexatic-backend/integration-api.proto",
}

const (
	ReplicateService_Chat_FullMethodName     = "/integration_api.ReplicateService/Chat"
	ReplicateService_Generate_FullMethodName = "/integration_api.ReplicateService/Generate"
)

// ReplicateServiceClient is the client API for ReplicateService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type ReplicateServiceClient interface {
	Chat(ctx context.Context, in *ReplicateChatRequest, opts ...grpc.CallOption) (*ReplicateChatResponse, error)
	Generate(ctx context.Context, in *ReplicateGenerateRequest, opts ...grpc.CallOption) (*ReplicateGenerateResponse, error)
}

type replicateServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewReplicateServiceClient(cc grpc.ClientConnInterface) ReplicateServiceClient {
	return &replicateServiceClient{cc}
}

func (c *replicateServiceClient) Chat(ctx context.Context, in *ReplicateChatRequest, opts ...grpc.CallOption) (*ReplicateChatResponse, error) {
	out := new(ReplicateChatResponse)
	err := c.cc.Invoke(ctx, ReplicateService_Chat_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *replicateServiceClient) Generate(ctx context.Context, in *ReplicateGenerateRequest, opts ...grpc.CallOption) (*ReplicateGenerateResponse, error) {
	out := new(ReplicateGenerateResponse)
	err := c.cc.Invoke(ctx, ReplicateService_Generate_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ReplicateServiceServer is the server API for ReplicateService service.
// All implementations should embed UnimplementedReplicateServiceServer
// for forward compatibility
type ReplicateServiceServer interface {
	Chat(context.Context, *ReplicateChatRequest) (*ReplicateChatResponse, error)
	Generate(context.Context, *ReplicateGenerateRequest) (*ReplicateGenerateResponse, error)
}

// UnimplementedReplicateServiceServer should be embedded to have forward compatible implementations.
type UnimplementedReplicateServiceServer struct {
}

func (UnimplementedReplicateServiceServer) Chat(context.Context, *ReplicateChatRequest) (*ReplicateChatResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Chat not implemented")
}
func (UnimplementedReplicateServiceServer) Generate(context.Context, *ReplicateGenerateRequest) (*ReplicateGenerateResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Generate not implemented")
}

// UnsafeReplicateServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to ReplicateServiceServer will
// result in compilation errors.
type UnsafeReplicateServiceServer interface {
	mustEmbedUnimplementedReplicateServiceServer()
}

func RegisterReplicateServiceServer(s grpc.ServiceRegistrar, srv ReplicateServiceServer) {
	s.RegisterService(&ReplicateService_ServiceDesc, srv)
}

func _ReplicateService_Chat_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ReplicateChatRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ReplicateServiceServer).Chat(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ReplicateService_Chat_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ReplicateServiceServer).Chat(ctx, req.(*ReplicateChatRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ReplicateService_Generate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ReplicateGenerateRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ReplicateServiceServer).Generate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ReplicateService_Generate_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ReplicateServiceServer).Generate(ctx, req.(*ReplicateGenerateRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// ReplicateService_ServiceDesc is the grpc.ServiceDesc for ReplicateService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var ReplicateService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "integration_api.ReplicateService",
	HandlerType: (*ReplicateServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Chat",
			Handler:    _ReplicateService_Chat_Handler,
		},
		{
			MethodName: "Generate",
			Handler:    _ReplicateService_Generate_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "lexatic-backend/integration-api.proto",
}

const (
	SendgridService_WelcomeEmail_FullMethodName       = "/integration_api.SendgridService/WelcomeEmail"
	SendgridService_ResetPasswordEmail_FullMethodName = "/integration_api.SendgridService/ResetPasswordEmail"
	SendgridService_InviteMemberEmail_FullMethodName  = "/integration_api.SendgridService/InviteMemberEmail"
)

// SendgridServiceClient is the client API for SendgridService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type SendgridServiceClient interface {
	WelcomeEmail(ctx context.Context, in *WelcomeEmailRequest, opts ...grpc.CallOption) (*WelcomeEmailResponse, error)
	ResetPasswordEmail(ctx context.Context, in *ResetPasswordEmailRequest, opts ...grpc.CallOption) (*ResetPasswordEmailResponse, error)
	InviteMemberEmail(ctx context.Context, in *InviteMemeberEmailRequest, opts ...grpc.CallOption) (*InviteMemeberEmailResponse, error)
}

type sendgridServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewSendgridServiceClient(cc grpc.ClientConnInterface) SendgridServiceClient {
	return &sendgridServiceClient{cc}
}

func (c *sendgridServiceClient) WelcomeEmail(ctx context.Context, in *WelcomeEmailRequest, opts ...grpc.CallOption) (*WelcomeEmailResponse, error) {
	out := new(WelcomeEmailResponse)
	err := c.cc.Invoke(ctx, SendgridService_WelcomeEmail_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *sendgridServiceClient) ResetPasswordEmail(ctx context.Context, in *ResetPasswordEmailRequest, opts ...grpc.CallOption) (*ResetPasswordEmailResponse, error) {
	out := new(ResetPasswordEmailResponse)
	err := c.cc.Invoke(ctx, SendgridService_ResetPasswordEmail_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *sendgridServiceClient) InviteMemberEmail(ctx context.Context, in *InviteMemeberEmailRequest, opts ...grpc.CallOption) (*InviteMemeberEmailResponse, error) {
	out := new(InviteMemeberEmailResponse)
	err := c.cc.Invoke(ctx, SendgridService_InviteMemberEmail_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// SendgridServiceServer is the server API for SendgridService service.
// All implementations should embed UnimplementedSendgridServiceServer
// for forward compatibility
type SendgridServiceServer interface {
	WelcomeEmail(context.Context, *WelcomeEmailRequest) (*WelcomeEmailResponse, error)
	ResetPasswordEmail(context.Context, *ResetPasswordEmailRequest) (*ResetPasswordEmailResponse, error)
	InviteMemberEmail(context.Context, *InviteMemeberEmailRequest) (*InviteMemeberEmailResponse, error)
}

// UnimplementedSendgridServiceServer should be embedded to have forward compatible implementations.
type UnimplementedSendgridServiceServer struct {
}

func (UnimplementedSendgridServiceServer) WelcomeEmail(context.Context, *WelcomeEmailRequest) (*WelcomeEmailResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method WelcomeEmail not implemented")
}
func (UnimplementedSendgridServiceServer) ResetPasswordEmail(context.Context, *ResetPasswordEmailRequest) (*ResetPasswordEmailResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ResetPasswordEmail not implemented")
}
func (UnimplementedSendgridServiceServer) InviteMemberEmail(context.Context, *InviteMemeberEmailRequest) (*InviteMemeberEmailResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method InviteMemberEmail not implemented")
}

// UnsafeSendgridServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to SendgridServiceServer will
// result in compilation errors.
type UnsafeSendgridServiceServer interface {
	mustEmbedUnimplementedSendgridServiceServer()
}

func RegisterSendgridServiceServer(s grpc.ServiceRegistrar, srv SendgridServiceServer) {
	s.RegisterService(&SendgridService_ServiceDesc, srv)
}

func _SendgridService_WelcomeEmail_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(WelcomeEmailRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SendgridServiceServer).WelcomeEmail(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: SendgridService_WelcomeEmail_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SendgridServiceServer).WelcomeEmail(ctx, req.(*WelcomeEmailRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SendgridService_ResetPasswordEmail_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ResetPasswordEmailRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SendgridServiceServer).ResetPasswordEmail(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: SendgridService_ResetPasswordEmail_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SendgridServiceServer).ResetPasswordEmail(ctx, req.(*ResetPasswordEmailRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SendgridService_InviteMemberEmail_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(InviteMemeberEmailRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SendgridServiceServer).InviteMemberEmail(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: SendgridService_InviteMemberEmail_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SendgridServiceServer).InviteMemberEmail(ctx, req.(*InviteMemeberEmailRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// SendgridService_ServiceDesc is the grpc.ServiceDesc for SendgridService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var SendgridService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "integration_api.SendgridService",
	HandlerType: (*SendgridServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "WelcomeEmail",
			Handler:    _SendgridService_WelcomeEmail_Handler,
		},
		{
			MethodName: "ResetPasswordEmail",
			Handler:    _SendgridService_ResetPasswordEmail_Handler,
		},
		{
			MethodName: "InviteMemberEmail",
			Handler:    _SendgridService_InviteMemberEmail_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "lexatic-backend/integration-api.proto",
}
